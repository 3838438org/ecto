\hypertarget{namespaceecto_1_1py}{}\section{ecto\+:\+:py Namespace Reference}
\label{namespaceecto_1_1py}\index{ecto\+::py@{ecto\+::py}}
\subsection*{Classes}
\begin{DoxyCompactItemize}
\item 
class \hyperlink{classecto_1_1py_1_1gil}{gil}
\item 
struct \hyperlink{structecto_1_1py_1_1gilstatus}{gilstatus}
\item 
struct \hyperlink{structecto_1_1py_1_1istream}{istream}
\item 
class \hyperlink{classecto_1_1py_1_1nothing__to__lock}{nothing\+\_\+to\+\_\+lock}
\item 
struct \hyperlink{structecto_1_1py_1_1ostream}{ostream}
\item 
class \hyperlink{classecto_1_1py_1_1scoped__call__back__to__python}{scoped\+\_\+call\+\_\+back\+\_\+to\+\_\+python}
\item 
class \hyperlink{classecto_1_1py_1_1scoped__gil__release}{scoped\+\_\+gil\+\_\+release}
\item 
class \hyperlink{classecto_1_1py_1_1streambuf}{streambuf}
\item 
struct \hyperlink{structecto_1_1py_1_1streambuf__capsule}{streambuf\+\_\+capsule}
\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
std\+::string \hyperlink{namespaceecto_1_1py_a103dc3e3c8ee425860ae2260f930752e}{file\+\_\+and\+\_\+line\+\_\+as\+\_\+string} (const char $\ast$file, long line)
\begin{DoxyCompactList}\small\item\em A stream buffer getting data from and putting data into a Python file object. \end{DoxyCompactList}\item 
std\+::string \hyperlink{namespaceecto_1_1py_abc1149eb9720c52fa9191bf7ee10ccf2}{repr} (const boost\+::python\+::object \&obj)
\item 
void \hyperlink{namespaceecto_1_1py_a9baa9f1e5394841101cbdc2eab37094c}{postregistration} (const std\+::string \&, const std\+::string \&, const std\+::string \&)
\end{DoxyCompactItemize}


\subsection{Function Documentation}
\index{ecto\+::py@{ecto\+::py}!file\+\_\+and\+\_\+line\+\_\+as\+\_\+string@{file\+\_\+and\+\_\+line\+\_\+as\+\_\+string}}
\index{file\+\_\+and\+\_\+line\+\_\+as\+\_\+string@{file\+\_\+and\+\_\+line\+\_\+as\+\_\+string}!ecto\+::py@{ecto\+::py}}
\subsubsection[{\texorpdfstring{file\+\_\+and\+\_\+line\+\_\+as\+\_\+string(const char $\ast$file, long line)}{file_and_line_as_string(const char *file, long line)}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::string ecto\+::py\+::file\+\_\+and\+\_\+line\+\_\+as\+\_\+string (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{file, }
\item[{long}]{line}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespaceecto_1_1py_a103dc3e3c8ee425860ae2260f930752e}{}\label{namespaceecto_1_1py_a103dc3e3c8ee425860ae2260f930752e}


A stream buffer getting data from and putting data into a Python file object. 

The aims are as follow\+:


\begin{DoxyItemize}
\item Given a C++ function acting on a standard stream, e.\+g.
\end{DoxyItemize}


\begin{DoxyCode}
\textcolor{keywordtype}{void} read\_inputs(std::istream& input) \{
  ...
  input >> something >> something\_else;
\}
\end{DoxyCode}


and given a piece of Python code which creates a file-\/like object, to be able to pass this file object to that C++ function, e.\+g.


\begin{DoxyCode}
\textcolor{keyword}{import} gzip
gzip\_file\_obj = gzip.GzipFile(...)
read\_inputs(gzip\_file\_obj)
\end{DoxyCode}


and have the standard stream pull data from and put data into the Python file object.


\begin{DoxyItemize}
\item When Python {\ttfamily read\+\_\+inputs()} returns, the Python object is able to continue reading or writing where the C++ code left off.
\item Operations in C++ on mere files should be competitively fast compared to the direct use of {\ttfamily std\+::fstream}.
\end{DoxyItemize}

{\bfseries Motivation} 


\begin{DoxyItemize}
\item the standard Python library offer of file-\/like objects (files, compressed files and archives, network, ...) is far superior to the offer of streams in the C++ standard library and Boost C++ libraries.
\item i/o code involves a fair amount of text processing which is more efficiently prototyped in Python but then one may need to rewrite a time-\/critical part in C++, in as seamless a manner as possible.
\end{DoxyItemize}

{\bfseries Usage} 

This is 2-\/step\+:


\begin{DoxyItemize}
\item a trivial wrapper function
\end{DoxyItemize}


\begin{DoxyCode}
\textcolor{keyword}{using} ecto::python::streambuf;
\textcolor{keywordtype}{void} read\_inputs\_wrapper(streambuf& input)
\{
  streambuf::istream is(input);
  read\_inputs(is);
\}

def(\textcolor{stringliteral}{"read\_inputs"}, read\_inputs\_wrapper);
\end{DoxyCode}


which has to be written every time one wants a Python binding for such a C++ function.


\begin{DoxyItemize}
\item the Python side
\end{DoxyItemize}


\begin{DoxyCode}
from \hyperlink{namespaceboost}{boost}.\hyperlink{namespaceboost_1_1python}{python} \textcolor{keyword}{import} streambuf
read\_inputs(streambuf(python\_file\_obj=obj, buffer\_size=1024))
\end{DoxyCode}


{\ttfamily buffer\+\_\+size} is optional. See also\+: {\ttfamily default\+\_\+buffer\+\_\+size} 

Note\+: references are to the C++ standard (the numbers between parentheses at the end of references are margin markers). \index{ecto\+::py@{ecto\+::py}!postregistration@{postregistration}}
\index{postregistration@{postregistration}!ecto\+::py@{ecto\+::py}}
\subsubsection[{\texorpdfstring{postregistration(const std\+::string \&, const std\+::string \&, const std\+::string \&)}{postregistration(const std::string &, const std::string &, const std::string &)}}]{\setlength{\rightskip}{0pt plus 5cm}void ecto\+::py\+::postregistration (
\begin{DoxyParamCaption}
\item[{const std\+::string \&}]{, }
\item[{const std\+::string \&}]{, }
\item[{const std\+::string \&}]{}
\end{DoxyParamCaption}
)}\hypertarget{namespaceecto_1_1py_a9baa9f1e5394841101cbdc2eab37094c}{}\label{namespaceecto_1_1py_a9baa9f1e5394841101cbdc2eab37094c}
\index{ecto\+::py@{ecto\+::py}!repr@{repr}}
\index{repr@{repr}!ecto\+::py@{ecto\+::py}}
\subsubsection[{\texorpdfstring{repr(const boost\+::python\+::object \&obj)}{repr(const boost::python::object &obj)}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::string ecto\+::py\+::repr (
\begin{DoxyParamCaption}
\item[{const boost\+::python\+::object \&}]{obj}
\end{DoxyParamCaption}
)}\hypertarget{namespaceecto_1_1py_abc1149eb9720c52fa9191bf7ee10ccf2}{}\label{namespaceecto_1_1py_abc1149eb9720c52fa9191bf7ee10ccf2}
